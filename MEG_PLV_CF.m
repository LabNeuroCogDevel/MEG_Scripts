function [ Output ] = MEG_PLV_CF( Input, trials, source, target, f1, f2, baseline, trial, foi,n)
% This function will calculate **cross frequency** phase-locking value of 
% MEG source timecourses from 2 ROIs. 
%   Usage: [ PLV, timeVec, FOIs ] = MEG_PLV( Input, trilas, source, target)
%
%   Input:
%       Input - This has to be output structure generated by MEG_wavelet.
%       trials - vector of trials to be included. Use [] to include all
%       trials.
%       source - the first ROI number
%       target - the second ROI number
%       f1 - the frequency of interest in ROI1
%       f2 - the frequency of interest in ROI2
%       Note that f1/f2 should be an integar. The length of f1 and f2 must 
%       be equal, and f1<f2.
%       baseline - start and end of baseline period in seconds ([-2.5,
%       -1.5])
%       trial - start and end of task period in seconds ([-2.5, 1.5])
%       foi - the frequencies of interest.
%       n - the ratio of frequency coupling.
%
%   Output:
%       Output.PLV = the time-frequency matrix of PLVs, freq x time.
%       Output.time - the time vector
%       Output.FOIs - frequency of interest.
%       Output.PLV_percent_change - normalized to change relative to
%       baseline.
%       Output.trialinfo
%       Output.trial_time - time vector of task period.
%
%   Last update  1.29.2013, by Kai

%find baseline start and end indeces 
bstart = find(min(abs(Input.time-(baseline(1))))==abs(Input.time-(baseline(1))));
bend = find(min(abs(Input.time-(baseline(2))))==abs(Input.time-(baseline(2))));

%find trial start and end indeces 
tstart = find(min(abs(Input.time-(trial(1))))==abs(Input.time-(trial(1))));
tend = find(min(abs(Input.time-(trial(2))))==abs(Input.time-(trial(2))));

%extract data
if isempty(trials)
    SourceData = squeeze(Input.wav(source,:,f1,:));
    TargetData = squeeze(Input.wav(target,:,f2,:));
else
    SourceData = squeeze(Input.wav(source,trials,f1,:));
    TargetData = squeeze(Input.wav(target,trials,f2,:));
end

%n= FOIf2(1)/f1(1);

%calculate PLV
% angle(wavelet_coef) will give you phase vector.
% angle(wavelet_coef_from_ROI1 .* conj(wavelet_coef_from_ROI2)) will give phase diff.
% exp(i*(phase)) will convert the complex number vector into unit length.
Output.PLV = squeeze(abs(mean(exp(1i*(angle((SourceData.^n).*conj(TargetData)))))));

%normalize PLV ot precent change from baseline
baseline_mean = squeeze(nanmean(Output.PLV(:,bstart:bend),2));
b_mean = repmat(baseline_mean, [1 tend-tstart+1]);
Output.PLV_percent_change = ((Output.PLV(:,tstart:tend)./b_mean)-1).*100;

Output.time = Input.time;
Output.trial_time = Input.time(tstart:tend);
Output.FOIs = foi;
Output.label = Input.label;
Output.trialinfo = Input.trialinfo;
Output.Subj = Input.Subj;
Output.n = n;
%Output.fsample = input.fsample;
end

