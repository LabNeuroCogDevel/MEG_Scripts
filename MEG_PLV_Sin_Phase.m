function [ Output ] = MEG_PLV_Sin_Phase( Input, Sin, trials, ROI, baseline, trial)
% This function will calculate phase-locking value of MEG source
% timecourses from in relation to an generated sin wave. The purpose is to 
% see if there is any "phase reset".
%   Usage: [ PLV, timeVec, FOIs ] = MEG_PLV_Sin_Phase( Input, trials, ROI
%           baseline, trial)
%
%   Input:
%       Input - This has to be output structure generated by MEG_wavelet.
%       trials - vector of trials to be included. Use [] to include all
%       trials.
%       Sin   - this is a structure similar to 'input', but with wavelet
%       outputs from artificial sin waves.
%       ROI   - the ROI number
%       baseline - start and end of baseline period in seconds ([-2.5,
%       -1.5])
%       trial - start and end of task period in seconds ([-2.5, 1.5])
%
%
%   Output:
%       Output.PLV = the time-frequency matrix of PLVs, freq x time.
%       Output.time - the time vector
%       Output.FOIs - frequency of interest.
%       Output.PLV_percent_change - normalized to change relative to
%       baseline.
%       Output.trialinfo
%       Output.trial_time - time vector of task period.
%
%   Last update  Feb.22.2013, by Kai

%find baseline start and end indeces 
bstart = find(min(abs(Input.time-(baseline(1))))==abs(Input.time-(baseline(1))));
bend = find(min(abs(Input.time-(baseline(2))))==abs(Input.time-(baseline(2))));

%find trial start and end indeces 
tstart = find(min(abs(Input.time-(trial(1))))==abs(Input.time-(trial(1))));
tend = find(min(abs(Input.time-(trial(2))))==abs(Input.time-(trial(2))));

%extract data
if isempty(trials)
    SourceData = squeeze(Input.wav(ROI,:,:,:));
    TargetData = squeeze(Sin.wav(ROI,:,:,:));
%     t=1:1:size(TargetData,3);
%     for f = 1:length(Input.FOIs)
%         for tt = 1:size(TargetData,1);
%         TargetData(tt,f,:)=sin(2*pi*Input.FOIs(f)/fs*t);
%         end
%     end
    
else
    SourceData = squeeze(Input.wav(ROI,trials,:,:));
    TargetData = squeeze(Sin.wav(ROI,trials,:,:));
%    TargetData = squeeze(Input.wav(ROI,:,:,:));
%     t=0:1:size(TargetData,3);
%     for f = 1:length(Input.FOIs)
%         for tt = 1:size(TargetData,1)
%         TargetData(tt,f,:)=sin(2*pi*Input.FOIs(f)/fs*t)
%         end
%     end
end


%calculate PLV
% angle(wavelet_coef) will give you phase vector.
% angle(wavelet_coef_from_ROI1 .* conj(wavelet_coef_from_ROI2)) will give phase diff.
% exp(i*(phase)) will convert the complex number vector into unit length.
Output.PLV = squeeze(abs(mean(exp(1i*(angle(SourceData.*conj(TargetData)))))));

%normalize PLV ot precent change from baseline
baseline_mean = squeeze(nanmean(Output.PLV(:,bstart:bend),2));
b_mean = repmat(baseline_mean, [1 tend-tstart+1]);
Output.PLV_percent_change = ((Output.PLV(:,tstart:tend)./b_mean)-1).*100;

Output.time = Input.time;
Output.trial_time = Input.time(tstart:tend);
Output.FOIs = Input.FOIs;
Output.label = Input.label;
Output.trialinfo = Input.trialinfo;
Output.Subj = Input.Subj;
%Output.fsample = input.fsample;
end

% function y = phasevec(f,s,Fs,width)
% % function y = phasevec(f,s,Fs,width)
% %
% % Return a the phase as a function of time for frequency f. 
% % The phase is calculated using Morlet's wavelets. 
% % Kai note: not phase, wavelet coef..??
% %
% % Fs: sampling frequency
% % width : width of Morlet wavelet (>= 5 suggested).
% %
% % Ref: Tallon-Baudry et al., J. Neurosci. 15, 722-734 (1997)
% 
% 
% dt = 1/Fs;
% sf = f/width;
% st = 1/(2*pi*sf);
% 
% t=-3.5*st:dt:3.5*st;
% m = morlet(f,t,width);
% 
% y = conv(s,m);
% 
% %l = abs(y) == 0; 
% %y(l) = 1;
% 
% %normalize power to 1
% %y = y./abs(y);
% %y(l) = 0;
%    
% % remove edges
% y = y(ceil(length(m)/2):length(y)-floor(length(m)/2));
% end
% 
% 
% 
% function y = morlet(f,t,width)
% % function y = morlet(f,t,width)
% % 
% % Morlet's wavelet for frequency f and time t. 
% % The wavelet will be normalized so the total energy is 1.
% % width defines the ``width'' of the wavelet. 
% % A value >= 5 is suggested.
% %
% % Ref: Tallon-Baudry et al., J. Neurosci. 15, 722-734 (1997)
% %
% %
% % Ole Jensen, August 1998 
% 
% sf = f/width;
% st = 1/(2*pi*sf);
% A = 1/sqrt(st*sqrt(pi));
% y = A*exp(-t.^2/(2*st^2)).*exp(i*2*pi*f.*t);
% end
